{"name":"glbinding","tagline":"A customizable C++ binding for the OpenGL API, generated using the gl.xml specification. ","body":"![Alt glbinding](https://raw.githubusercontent.com/hpicgs/glbinding/master/glbinding-logo.svg)\r\n<img src=\"https://raw.githubusercontent.com/hpicgs/glbinding/master/glbinding-logo.svg\">\r\n\r\nglbinding-1.0.2 was just released: [goto release](https://github.com/hpicgs/glbinding/releases/tag/v1.0.2)\r\n\r\n*glbinding* is a generated, cross-platform C++ binding for OpenGL which is solely based on the new xml-based OpenGL API specification ([gl.xml](https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/gl.xml)). It is a fully fledged OpenGL API binding compatible with current code based on other C bindings, e.g., [GLEW](http://glew.sourceforge.net/). The binding is generated using python scripts and templates, that can be easily adapted to fit custom needs.\r\n*glbinding* can be used as an alternative to GLEW and other projects, e.g., [glad](https://github.com/Dav1dde/glad), [gl3w](https://github.com/skaslev/gl3w), [glLoadGen](https://bitbucket.org/alfonse/glloadgen/overview), [glload](http://glsdk.sourceforge.net/docs/html/group__module__glload.html), and [flextGL](https://github.com/ginkgo/flextGL).\r\n\r\n*glbinding* leverages modern C++11 features like enum classes, lambdas, and variadic templates, instead of relying on macros (all OpenGL symbols are real functions and variables). It provides [type-safe parameters](#type-safe-parameters), [per feature API header](#per-feature-api-header), [lazy function resolution](#lazy-function-pointer-resolution), [multi-context](#multi-context-support) and [multi-thread](#multi-threading-support) support, [global](#function-callbacks) function callbacks, [meta information](#meta-information) about the generated OpenGL binding and the OpenGL runtime, as well as multiple [examples](https://github.com/hpicgs/glbinding/wiki/examples) for quick-starting your projects. \r\n\r\nCurrent gl code, written with a typical C binding for OpenGL is fully compatible for the use with *glbinding*.\r\nJust replace all includes to the old binding and use the appropriate api namespace, e.g., ```gl```: \r\n\r\n```c++\r\n#include <glbinding/gl/gl.h>\r\n#include <glbinding/Binding.h>\r\n\r\nusing namespace gl;\r\n\r\nint main()\r\n{\r\n  // create context, e.g. using GLFW, Qt, SDL, GLUT, ...\r\n\r\n  glbinding::Binding::initialize();\r\n\r\n  glBegin(GL_TRIANGLES);\r\n  // ...\r\n  glEnd();\r\n}\r\n```\r\n\r\n## Features\r\n\r\n##### Type-Safe Parameters\r\n\r\nEvery parameter of an OpenGL function expects a specific type of value and *glbinding* enforces, if possible, this type in its interface. This results in the following behavior:\r\n```c++\r\nglClear(GL_COLOR_BUFFER_BIT); // valid\r\nglClear(GL_FRAMEBUFFER);      // compile error: bitfield of group ClearBufferMask expected, got GLenum\r\n```\r\nFor bitfields there are extensively specified groups that are additionally used to enforce type-safety (a bitfield value can be used by several groups). Combinations of bitfields that share no group results in a compile error.\r\n```c++\r\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // valid\r\nglClear(GL_COLOR_BUFFER_BIT | GL_MAP_READ_BIT);     // compile error: both bitfields share no group\r\n\r\nglClear(GL_STENCIL_BUFFER_BIT | GL_LIGHTING_BIT);   // compile error: bitwise or operation is valid, \r\n                                                    //  the shared group is AttribMask, but the\r\n                                                    //  resulting group does not match the expected.\r\n```\r\nThe groups for enums are not yet as complete as we would like them to be to enable per function compile time errors when trying to call functions with values from the wrong enum group. For example, ```GL_VERTEX_SHADER``` is in the group ```ShaderType``` and ```GL_COMPUTE_SHADER``` is not.\r\n\r\n##### Per Feature API Header\r\n\r\nEnums, bitfields, and functions can be included as usual in a combined ```gl.h``` header or individually via ```bitfield.h```, ```enum.h```, and ```functions.h``` respectively. Additionally, these headers are available for  featured-based API subsets, each using a specialized namespace, e.g.:\r\n* ```functions32.h``` provides all OpenGL commands available up to 3.2 in namespace ```gl32```.\r\n* ```functions32core.h``` provides all non-deprecated OpenGL commands available up to 3.2 in namespace ```gl32core```.\r\n* ```functions32ext.h``` provides all OpenGL commands specified either in 3.3 and above, or by extension in ```gl32ext```.\r\n\r\nDepending on the intended use-case, this allows to (1) limit coding to a specific OpenGL feature and (2) reduces switching to other features to a replacement of includes and using directives. In both cases, non-featured symbols do not compile.\r\n\r\nFurthermore, *glbinding* provides explicit, non-feature dependent headers for special values (```values.h```), booleans (```boolean.h```), and basic types (```types.h```). This allows for refined includes and can reduce compile time.\r\n\r\n\r\n##### Lazy Function Pointer Resolution\r\n\r\nBy default, *glbinding* tries to resolve all OpenGL function pointers during initialization, which can consume some time:\r\n```c++\r\nglbinding::Binding::initialize(); // immediate function pointer resolution\r\n```\r\nAlternatively, the user can decide that functions pointers are resolved only when used for the first time. This is achieved by:\r\n```c++\r\nglbinding::Binding::initialize(false); // lazy function pointer resolution\r\n```\r\n\r\n##### Multi-Context Support\r\n\r\n*glbinding* has built-in support for multiple contexts. The only requirement is, that the currently active context has to be specified. This feature mixes well with multi-threaded applications, but keep in mind that concurrent use of one context often result in non-meaningful communication with the OpenGL driver.\r\n\r\nTo use multiple contexts, use your favorite context creation library (e.g., glut, SDL, egl, glfw, Qt) to request as much contexts as required. The functions to make a context current should be provided by this library and is not part of *glbinding* (except that you can get the current context handle). When using multiple contexts, first, each has to be initialized when active: \r\n```c++\r\n// use context library to make current, e.g., glfwMakeCurrent(...)\r\nglbinding::Binding::initialize();\r\n```\r\nSecond, contexts switches are required to be communicated to *glinding* explicitly in order to have correctly dispatched function pointers:\r\n```c++\r\n// use the current active context\r\nglbinding::Binding::useCurrentContext();               \r\n\r\n// use another context, identified by platform-specific handle\r\nglbinding::Binding::useContext(ContextHandle context); \r\n```\r\nThis feature is mainly intended for platforms where function pointers for different requested OpenGL features may vary.\r\n\r\n\r\n##### Multi-Threading Support\r\n\r\nConcurrent use of *glbinding* is mainly intended to the usage of multiple contexts in different threads (multiple threads operating on a single OpenGL context requires locking, which *glbinding* will not provide).\r\nFor this, *glbinding* supports multiple active contexts, one per thread. This necessitates that *glbinding* gets informed in each thread which context is currently active (see [multi-context](#multi-context-support)).\r\n\r\n\r\n##### Function Callbacks\r\n\r\n*glbinding* supports different types of callbacks that can be registered.\r\nThe main types are\r\n * Before callbacks, that are called before the OpenGL function is called\r\n * After callbacks, that are called after the OpenGL function call\r\n * Unresolved callbacks, that are called each time an unresolved OpenGL function should be called (instead of a segmentation fault)\r\n\r\nThe before callbacks are useful , e.g., for tracing or application-specific parameter checking.\r\nThe available informations in this callback are the wrapped OpenGL function (including its name and bound function address) and all parameters.\r\nThe after callbacks are useful, .e.g., for tracing, logging, or the obligatory error check.\r\nAvailable informations are extended by the return value.\r\nThe unresolved callback provides information about the (unresolved) wrapped OpenGL function object.\r\n\r\nAll callbacks are currently global (per thread, per context, and per function) but are intended to become local in the future.\r\n\r\nExample for error checking:\r\n```c++\r\n#include <glbinding/callbacks.h>\r\n\r\nusing namespace glbinding;\r\n\r\n// ...\r\nsetCallbackMask(CallbackMask::After);\r\nsetAfterCallback([](const FunctionCall &)\r\n{\r\n  GLenum error = glGetError();\r\n  if (error != GL_NO_ERROR)\r\n    std::cout << \"error: \" << std::hex << error << std::endl;\r\n});\r\n\r\n// ... OpenGL code\r\n```\r\n\r\nExample for logging:\r\n```c++\r\n#include <glbinding/callbacks.h>\r\n\r\nusing namespace glbinding;\r\n\r\n// ...\r\nsetCallbackMask(CallbackMask::After | CallbackMask::ParametersAndReturnValue);\r\nglbinding::setAfterCallback([](const glbinding::FunctionCall & call)\r\n{\r\n  std::cout << call.function.name() << \"(\";\r\n  \r\n  for (unsigned i = 0; i < call.parameters.size(); ++i)\r\n  {\r\n    std::cout << call.parameters[i]->asString();\r\n    if (i < call.parameters.size() - 1)\r\n      std::cout << \", \";\r\n  }\r\n  \r\n  std::cout << \")\";\r\n  \r\n  if (call.returnValue)\r\n  {\r\n    std::cout << \" -> \" << call.returnValue->asString();\r\n  }\r\n  \r\n  std::cout << std::endl;\r\n});\r\n\r\n// ... OpenGL code\r\n```\r\n\r\n##### Meta Information\r\n\r\nBesides an actual OpenGL binding, *glbinding* also supports queries for both compile time and compile time information about the gl.xml and your OpenGL driver.\r\nTypical use cases are querying the available OpenGL extensions or the associated extensions to an OpenGL feature and their functions and enums.\r\n\r\nExample list of all available OpenGL versions/features (compile time):\r\n```c++\r\n#include <glbinding/Meta.h>\r\n\r\nusing glbinding::Meta;\r\n\r\nfor (Version v : Meta::versions())\r\n  std::cout << v.toString() << std::endl;\r\n```\r\n\r\nExample output of all enums (compile time):\r\n```c++\r\n#include <glbinding/Meta.h>\r\n\r\nusing glbinding::Meta;\r\n\r\nif (Meta::stringsByGL())\r\n{\r\n  std::cout << \"# Enums: \" << Meta::enums().size() << std::endl << std::endl;\r\n\r\n  for (GLenum e : Meta::enums()) // c++ 14 ...\r\n    std::cout << \" (\" << std::hex << std::showbase << std::internal << std::setfill('0') << std::setw(8) \r\n              << static_cast<std::underlying_type<GLenum>::type>(e) << \") \" << Meta::getString(e) << std::dec << std::endl;\r\n\r\n  std::cout << std::dec;\r\n}\r\n```\r\n\r\nExample output of all available extensions (run time):\r\n```c++\r\n#include <glbinding/Meta.h>\r\n\r\nusing glbinding::Meta;\r\n\r\nif (Meta::stringsByGL())\r\n{\r\n  std::cout << \" # Extensions: \" << Meta::extensions().size() << std::endl << std::endl;\r\n\r\n  for (GLextension e : Meta::extensions())\r\n  {\r\n    const Version v = Meta::getRequiringVersion(e);\r\n    std::cout << \" \" << Meta::getString(e) << \" \" << (v.isNull() ? \"\" : v.toString()) << std::endl;\r\n  }\r\n}\r\n```\r\n\r\n\r\n##### Performance\r\n\r\n*glbinding* causes no signigicant impact on runtime performance. The provided comparison example supports this statement. It compares the execution times of identical rendering code, dispatched once with *glbinding* and once with glew. Various results are provided in the [Examples](https://github.com/hpicgs/glbinding/wiki/examples) wiki.\r\n\r\n\r\n##### Binding Generation\r\n\r\nAs a user of glbinding you are able to update the gl.xml by yourself and generate the glbinding code.\r\nThe necessary python scripts are provided in this repository. Since the ```gl.xml``` is not complete, a ```patch.xml``` is used to resolve possible conflicts or missing specifications. With ongoing development of the xml-based OpenGL API specification this could become obsolete in the future.\r\n\r\n\r\n<!--\r\n## Status\r\n\r\nbuild status (@hourly for master): ![status](http://jenkins.hpi3d.de/buildStatus/icon?job=glbinding)\r\n-->\r\n\r\n## Using glbinding\r\n\r\n##### Dependencies\r\n\r\nThe only run-time dependencies of glbinding are the STL of the used compiler and an OpenGL library, dynamically linked with your application.\r\n\r\nOptional dependencies\r\n * Python 2 or 3 to generate the binding\r\n * Qt for some examples\r\n * [GLFW 3](http://www.glfw.org/) for some examples\r\n * GLEW for some examples\r\n\r\nFor building *glbinding* CMake 2.8.12 or newer and a C++11 compliant compiler (e.g. GCC 4.7, Clang 3.3, MSVC 2013 **Update 3**) are required.\r\n\r\nWhen configuring *glbinding*, the options ```OPTION_BUILD_EXAMPLES```, ```OPTION_GL_BY_STRINGS```, and ```OPTION_STRINGS_BY_GL``` can be used to enable example builds (qt-cubescape is only enabled when Qt5 is found), allow string-to-symbol and symbol-to-string conversion respectively (in ```Meta```). ```OPTION_GL_BY_STRINGS``` is disabled by default, since it increases build time for the MSVC 2013 compiler.\r\n\r\n\r\n##### Linking binaries\r\n\r\nIn order to link *glbinding* the *glbinding* path can be added to the ```CMAKE_PREFIX_PATH``` and ```find_package(glbinding REQUIRED)``` can be used in the appropriate ```CMakeLists.txt```. ```GLBINDING_INCLUDES``` and ```GLBINDING_LIBRARIES``` can then be added to include dirs and target libraries.\r\n","google":"UA-56090114-1","note":"Don't delete this file! It's used internally to help with page regeneration."}